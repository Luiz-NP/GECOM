function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React, { useRef, forwardRef, useImperativeHandle, useEffect, useState, useCallback, useMemo } from 'react';
import { StyleSheet, TextInput, TouchableWithoutFeedback, View, Text // @ts-ignore
, LogBox } from 'react-native';
import Animated, { useSharedValue, withTiming, useAnimatedStyle, interpolate, Extrapolate, interpolateColor } from 'react-native-reanimated';
const InputOutlineComponent = /*#__PURE__*/forwardRef((props, ref) => {
  // establish provided props
  const {
    // theme colors
    inactiveColor = 'grey',
    activeColor = 'blue',
    errorColor = 'red',
    backgroundColor = 'white',
    // fonts
    fontSize = 14,
    fontColor = 'black',
    fontFamily,
    error,
    errorFontSize = 10,
    errorFontFamily,
    assistiveText,
    assistiveTextFontSize = 10,
    assistiveTextColor = inactiveColor,
    assistiveFontFamily,
    characterCount,
    characterCountFontFamily,
    characterCountColor = inactiveColor,
    characterCountFontSize = 10,
    // styling
    paddingHorizontal = 16,
    paddingVertical = 12,
    roundness = 5,
    style,
    // features
    placeholder = 'Placeholder',
    trailingIcon,
    // others
    value: _providedValue = '',
    onChangeText,
    ...inputProps
  } = props; // value of input

  const [value, setValue] = useState(_providedValue); // animation vars

  const inputRef = useRef(null);
  const placeholderMap = useSharedValue(_providedValue ? 1 : 0);
  const placeholderSize = useSharedValue(0);
  const colorMap = useSharedValue(0); // helper functinos

  const focus = () => {
    var _inputRef$current;

    return (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
  };

  const blur = () => {
    var _inputRef$current2;

    return (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.blur();
  };

  const isFocused = () => {
    var _inputRef$current3;

    return Boolean((_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.isFocused());
  };

  const clear = () => {
    var _inputRef$current4;

    Boolean((_inputRef$current4 = inputRef.current) === null || _inputRef$current4 === void 0 ? void 0 : _inputRef$current4.clear());
    setValue('');
  };

  const errorState = useCallback(() => error !== null && error !== undefined, [error]);

  const handleFocus = () => {
    placeholderMap.value = withTiming(1); // focused

    if (!errorState()) colorMap.value = withTiming(1); // active

    focus();
  };

  const handleBlur = () => {
    if (!value) placeholderMap.value = withTiming(0); // blur

    if (!errorState()) colorMap.value = withTiming(0); // inactive

    blur();
  };

  const handleChangeText = text => {
    onChangeText && onChangeText(text);
    setValue(text);
  };

  const handlePlaceholderLayout = useCallback(({
    nativeEvent
  }) => {
    const {
      width
    } = nativeEvent.layout;
    placeholderSize.value = width;
  }, [placeholderSize]);
  const renderTrailingIcon = useCallback(() => {
    if (trailingIcon) return trailingIcon({});
    return null;
  }, [trailingIcon]); // handle value update

  useEffect(() => {
    if (_providedValue.length) placeholderMap.value = withTiming(1); // focused;

    setValue(_providedValue);
  }, [_providedValue, placeholderMap]); // error handling

  useEffect(() => {
    if (errorState()) {
      colorMap.value = 2; // error -- no animation here, snap to color immediately
    } else {
      colorMap.value = isFocused() ? 1 : 0; // to active or inactive color if focused
    }
  }, [error, colorMap, errorState]);
  const animatedPlaceholderStyles = useAnimatedStyle(() => ({
    transform: [{
      translateY: interpolate(placeholderMap.value, [0, 1], [0, -(paddingVertical + fontSize * 0.7)])
    }, {
      scale: interpolate(placeholderMap.value, [0, 1], [1, 0.7])
    }, {
      translateX: interpolate(placeholderMap.value, [0, 1], [0, -placeholderSize.value * 0.2])
    }]
  }));
  const animatedPlaceholderTextStyles = useAnimatedStyle(() => ({
    color: interpolateColor(colorMap.value, [0, 1, 2], [inactiveColor, activeColor, errorColor])
  }));
  const animatedPlaceholderSpacerStyles = useAnimatedStyle(() => ({
    width: interpolate(placeholderMap.value, [0, 1], [0, placeholderSize.value * 0.7 + 7], Extrapolate.CLAMP)
  }));
  const animatedContainerStyle = useAnimatedStyle(() => ({
    borderColor: placeholderSize.value > 0 ? interpolateColor(colorMap.value, [0, 1, 2], [inactiveColor, activeColor, errorColor]) : inactiveColor
  }));
  useImperativeHandle(ref, () => ({
    focus: handleFocus,
    blur: handleBlur,
    isFocused: isFocused(),
    clear: clear
  }));
  const styles = StyleSheet.create({
    container: {
      borderWidth: 1,
      borderRadius: roundness,
      alignSelf: 'stretch',
      flexDirection: 'row',
      backgroundColor
    },
    inputContainer: {
      flex: 1,
      paddingVertical,
      paddingHorizontal,
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center'
    },
    input: {
      flex: 1,
      fontSize,
      fontFamily,
      color: fontColor
    },
    placeholder: {
      position: 'absolute',
      top: paddingVertical,
      left: paddingHorizontal
    },
    placeholderText: {
      fontSize,
      fontFamily
    },
    placeholderSpacer: {
      position: 'absolute',
      top: -1,
      left: paddingHorizontal - 3,
      backgroundColor,
      height: 1
    },
    errorText: {
      position: 'absolute',
      color: errorColor,
      fontSize: errorFontSize,
      fontFamily: errorFontFamily,
      bottom: -errorFontSize - 7,
      left: paddingHorizontal
    },
    trailingIcon: {
      position: 'absolute',
      right: paddingHorizontal,
      alignSelf: 'center'
    },
    counterText: {
      position: 'absolute',
      color: errorState() ? errorColor : characterCountColor,
      fontSize: characterCountFontSize,
      bottom: -characterCountFontSize - 7,
      right: paddingHorizontal,
      fontFamily: characterCountFontFamily
    },
    assistiveText: {
      position: 'absolute',
      color: assistiveTextColor,
      fontSize: assistiveTextFontSize,
      bottom: -assistiveTextFontSize - 7,
      left: paddingHorizontal,
      fontFamily: assistiveFontFamily
    }
  });
  const placeholderStyle = useMemo(() => {
    return [styles.placeholder, animatedPlaceholderStyles];
  }, [styles.placeholder, animatedPlaceholderStyles]);
  return /*#__PURE__*/React.createElement(Animated.View, {
    style: [styles.container, animatedContainerStyle, style]
  }, /*#__PURE__*/React.createElement(TouchableWithoutFeedback, {
    onPress: handleFocus
  }, /*#__PURE__*/React.createElement(View, {
    style: styles.inputContainer
  }, /*#__PURE__*/React.createElement(TextInput, _extends({}, inputProps, {
    ref: inputRef,
    style: styles.input,
    pointerEvents: isFocused() ? 'auto' : 'none',
    onFocus: handleFocus,
    onBlur: handleBlur,
    onChangeText: handleChangeText,
    maxLength: characterCount ? characterCount : undefined,
    selectionColor: errorState() ? errorColor : activeColor,
    placeholder: "",
    value: value
  })))), trailingIcon && /*#__PURE__*/React.createElement(View, {
    style: styles.trailingIcon
  }, renderTrailingIcon()), /*#__PURE__*/React.createElement(Animated.View, {
    style: [styles.placeholderSpacer, animatedPlaceholderSpacerStyles]
  }), /*#__PURE__*/React.createElement(Animated.View, {
    style: placeholderStyle,
    onLayout: handlePlaceholderLayout,
    pointerEvents: "none"
  }, /*#__PURE__*/React.createElement(Animated.Text, {
    style: [styles.placeholderText, animatedPlaceholderTextStyles]
  }, placeholder)), characterCount && /*#__PURE__*/React.createElement(Text, {
    style: styles.counterText
  }, `${value.length} / ${characterCount}`), errorState() ? /*#__PURE__*/React.createElement(Text, {
    style: [styles.errorText]
  }, error) : assistiveText && /*#__PURE__*/React.createElement(Text, {
    style: [styles.assistiveText]
  }, assistiveText));
});
const InputOutline = InputOutlineComponent;
export { InputOutline }; // color issue

LogBox.ignoreLogs(['You are setting the style `{ color: ... }` as a prop.']);
//# sourceMappingURL=InputOutline.js.map