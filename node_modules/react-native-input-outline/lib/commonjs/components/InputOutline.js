"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InputOutline = void 0;

var _react = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _reactNativeReanimated = _interopRequireWildcard(require("react-native-reanimated"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const InputOutlineComponent = /*#__PURE__*/(0, _react.forwardRef)((props, ref) => {
  // establish provided props
  const {
    // theme colors
    inactiveColor = 'grey',
    activeColor = 'blue',
    errorColor = 'red',
    backgroundColor = 'white',
    // fonts
    fontSize = 14,
    fontColor = 'black',
    fontFamily,
    error,
    errorFontSize = 10,
    errorFontFamily,
    assistiveText,
    assistiveTextFontSize = 10,
    assistiveTextColor = inactiveColor,
    assistiveFontFamily,
    characterCount,
    characterCountFontFamily,
    characterCountColor = inactiveColor,
    characterCountFontSize = 10,
    // styling
    paddingHorizontal = 16,
    paddingVertical = 12,
    roundness = 5,
    style,
    // features
    placeholder = 'Placeholder',
    trailingIcon,
    // others
    value: _providedValue = '',
    onChangeText,
    ...inputProps
  } = props; // value of input

  const [value, setValue] = (0, _react.useState)(_providedValue); // animation vars

  const inputRef = (0, _react.useRef)(null);
  const placeholderMap = (0, _reactNativeReanimated.useSharedValue)(_providedValue ? 1 : 0);
  const placeholderSize = (0, _reactNativeReanimated.useSharedValue)(0);
  const colorMap = (0, _reactNativeReanimated.useSharedValue)(0); // helper functinos

  const focus = () => {
    var _inputRef$current;

    return (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
  };

  const blur = () => {
    var _inputRef$current2;

    return (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.blur();
  };

  const isFocused = () => {
    var _inputRef$current3;

    return Boolean((_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.isFocused());
  };

  const clear = () => {
    var _inputRef$current4;

    Boolean((_inputRef$current4 = inputRef.current) === null || _inputRef$current4 === void 0 ? void 0 : _inputRef$current4.clear());
    setValue('');
  };

  const errorState = (0, _react.useCallback)(() => error !== null && error !== undefined, [error]);

  const handleFocus = () => {
    placeholderMap.value = (0, _reactNativeReanimated.withTiming)(1); // focused

    if (!errorState()) colorMap.value = (0, _reactNativeReanimated.withTiming)(1); // active

    focus();
  };

  const handleBlur = () => {
    if (!value) placeholderMap.value = (0, _reactNativeReanimated.withTiming)(0); // blur

    if (!errorState()) colorMap.value = (0, _reactNativeReanimated.withTiming)(0); // inactive

    blur();
  };

  const handleChangeText = text => {
    onChangeText && onChangeText(text);
    setValue(text);
  };

  const handlePlaceholderLayout = (0, _react.useCallback)(({
    nativeEvent
  }) => {
    const {
      width
    } = nativeEvent.layout;
    placeholderSize.value = width;
  }, [placeholderSize]);
  const renderTrailingIcon = (0, _react.useCallback)(() => {
    if (trailingIcon) return trailingIcon({});
    return null;
  }, [trailingIcon]); // handle value update

  (0, _react.useEffect)(() => {
    if (_providedValue.length) placeholderMap.value = (0, _reactNativeReanimated.withTiming)(1); // focused;

    setValue(_providedValue);
  }, [_providedValue, placeholderMap]); // error handling

  (0, _react.useEffect)(() => {
    if (errorState()) {
      colorMap.value = 2; // error -- no animation here, snap to color immediately
    } else {
      colorMap.value = isFocused() ? 1 : 0; // to active or inactive color if focused
    }
  }, [error, colorMap, errorState]);
  const animatedPlaceholderStyles = (0, _reactNativeReanimated.useAnimatedStyle)(() => ({
    transform: [{
      translateY: (0, _reactNativeReanimated.interpolate)(placeholderMap.value, [0, 1], [0, -(paddingVertical + fontSize * 0.7)])
    }, {
      scale: (0, _reactNativeReanimated.interpolate)(placeholderMap.value, [0, 1], [1, 0.7])
    }, {
      translateX: (0, _reactNativeReanimated.interpolate)(placeholderMap.value, [0, 1], [0, -placeholderSize.value * 0.2])
    }]
  }));
  const animatedPlaceholderTextStyles = (0, _reactNativeReanimated.useAnimatedStyle)(() => ({
    color: (0, _reactNativeReanimated.interpolateColor)(colorMap.value, [0, 1, 2], [inactiveColor, activeColor, errorColor])
  }));
  const animatedPlaceholderSpacerStyles = (0, _reactNativeReanimated.useAnimatedStyle)(() => ({
    width: (0, _reactNativeReanimated.interpolate)(placeholderMap.value, [0, 1], [0, placeholderSize.value * 0.7 + 7], _reactNativeReanimated.Extrapolate.CLAMP)
  }));
  const animatedContainerStyle = (0, _reactNativeReanimated.useAnimatedStyle)(() => ({
    borderColor: placeholderSize.value > 0 ? (0, _reactNativeReanimated.interpolateColor)(colorMap.value, [0, 1, 2], [inactiveColor, activeColor, errorColor]) : inactiveColor
  }));
  (0, _react.useImperativeHandle)(ref, () => ({
    focus: handleFocus,
    blur: handleBlur,
    isFocused: isFocused(),
    clear: clear
  }));

  const styles = _reactNative.StyleSheet.create({
    container: {
      borderWidth: 1,
      borderRadius: roundness,
      alignSelf: 'stretch',
      flexDirection: 'row',
      backgroundColor
    },
    inputContainer: {
      flex: 1,
      paddingVertical,
      paddingHorizontal,
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center'
    },
    input: {
      flex: 1,
      fontSize,
      fontFamily,
      color: fontColor
    },
    placeholder: {
      position: 'absolute',
      top: paddingVertical,
      left: paddingHorizontal
    },
    placeholderText: {
      fontSize,
      fontFamily
    },
    placeholderSpacer: {
      position: 'absolute',
      top: -1,
      left: paddingHorizontal - 3,
      backgroundColor,
      height: 1
    },
    errorText: {
      position: 'absolute',
      color: errorColor,
      fontSize: errorFontSize,
      fontFamily: errorFontFamily,
      bottom: -errorFontSize - 7,
      left: paddingHorizontal
    },
    trailingIcon: {
      position: 'absolute',
      right: paddingHorizontal,
      alignSelf: 'center'
    },
    counterText: {
      position: 'absolute',
      color: errorState() ? errorColor : characterCountColor,
      fontSize: characterCountFontSize,
      bottom: -characterCountFontSize - 7,
      right: paddingHorizontal,
      fontFamily: characterCountFontFamily
    },
    assistiveText: {
      position: 'absolute',
      color: assistiveTextColor,
      fontSize: assistiveTextFontSize,
      bottom: -assistiveTextFontSize - 7,
      left: paddingHorizontal,
      fontFamily: assistiveFontFamily
    }
  });

  const placeholderStyle = (0, _react.useMemo)(() => {
    return [styles.placeholder, animatedPlaceholderStyles];
  }, [styles.placeholder, animatedPlaceholderStyles]);
  return /*#__PURE__*/_react.default.createElement(_reactNativeReanimated.default.View, {
    style: [styles.container, animatedContainerStyle, style]
  }, /*#__PURE__*/_react.default.createElement(_reactNative.TouchableWithoutFeedback, {
    onPress: handleFocus
  }, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: styles.inputContainer
  }, /*#__PURE__*/_react.default.createElement(_reactNative.TextInput, _extends({}, inputProps, {
    ref: inputRef,
    style: styles.input,
    pointerEvents: isFocused() ? 'auto' : 'none',
    onFocus: handleFocus,
    onBlur: handleBlur,
    onChangeText: handleChangeText,
    maxLength: characterCount ? characterCount : undefined,
    selectionColor: errorState() ? errorColor : activeColor,
    placeholder: "",
    value: value
  })))), trailingIcon && /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: styles.trailingIcon
  }, renderTrailingIcon()), /*#__PURE__*/_react.default.createElement(_reactNativeReanimated.default.View, {
    style: [styles.placeholderSpacer, animatedPlaceholderSpacerStyles]
  }), /*#__PURE__*/_react.default.createElement(_reactNativeReanimated.default.View, {
    style: placeholderStyle,
    onLayout: handlePlaceholderLayout,
    pointerEvents: "none"
  }, /*#__PURE__*/_react.default.createElement(_reactNativeReanimated.default.Text, {
    style: [styles.placeholderText, animatedPlaceholderTextStyles]
  }, placeholder)), characterCount && /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
    style: styles.counterText
  }, `${value.length} / ${characterCount}`), errorState() ? /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
    style: [styles.errorText]
  }, error) : assistiveText && /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
    style: [styles.assistiveText]
  }, assistiveText));
});
const InputOutline = InputOutlineComponent;
exports.InputOutline = InputOutline;

// color issue
_reactNative.LogBox.ignoreLogs(['You are setting the style `{ color: ... }` as a prop.']);
//# sourceMappingURL=InputOutline.js.map